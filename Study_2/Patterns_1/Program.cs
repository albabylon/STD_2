using Patterns_1.AbstractFactory.Factories;
using Patterns_1.AbstractFactory;
using Patterns_1.Singleton;
using System;
using Patterns_1.FactoryMethod.FactoryMethodRealExample;

namespace Patterns_1
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // KISS («Keep it simple, stupid») - чем системы проще, тем стабильнее и надежнее они работают.

            // DRY («Don't repeat yourself»)/DIE («Duplication Is Evil») - не повторяйся

            // YAGNI («You Ain't Gonna Need It») - Избыточный функционал нам не нужен, и при разработке стоит ограничиться необходимым минимумом,
            // но при этом заложить возможность расширения системы и добавления в неё дополнительных функций.




            /*------------------------------------------------------------------------------------------------------------------------------*/

            // ПОРОЖДАЮЩИЕ ПАТТЕРНЫ - Паттерны, которые позволяют реализовать более удобное и безопасное создание объектов в коде (инкапсуляция происходит)

            // SINGLETON - Имеет смысл, когда нам необходимо наличие только одного объекта определенного типа в коде.
            // Реализация Singleton позволяет нам получить такой объект и точку доступа к нему.
            // При этом создаётся он только тогда, когда необходим


            // создаем объект приложения
            Application app = new Application();

            // запускаем наше приложение (внутри создается соединение с базой данных по переданному адресу)
            app.Launch("10.30.60.80");
            Console.WriteLine(app.DbConnection.Configuration);

            // Теперь пробуем создать новое соединение с базой данных уже по другому адресу
            app.DbConnection = DbConnection.GetConnectionInstance("10.30.60.81");

            // у нас не получилось, так как объект уже существует
            Console.WriteLine(app.DbConnection.Configuration);




            /*------------------------------------------------------------------------------------------------------------------------------*/

            // АБСТРАКТНАЯ ФАБРИКА - Позволяет нам создавать группы связанных объектов без привязки к конкретным классам.

            // Создание дракона через фабрику
            var dragon = new Monster(new DragonFactory());
            dragon.Move();
            dragon.Hit();

            Console.WriteLine();
            // Создание орка через фабрику
            var orc = new Monster(new OrcFactory());
            orc.Move();
            orc.Hit();

            Console.WriteLine();
            Console.WriteLine("Всем конец...");
            // Среди преимуществ здесь можно отметить то, что создание монстра абстрагировано от самого класса монстра.
            // Но шаблон также имеет и свои недостатки. К примеру, если мы решим добавить монстрам новый объект конфигурации (например, тип брони),
            // то придётся переделывать и классы фабрик, и класс монстра.






            /*------------------------------------------------------------------------------------------------------------------------------*/

            // ФАБРИЧНЫЙ МЕТОД - Даёт нам возможность определить некую универсальную конструкцию для создания объектов в основном классе.
            // Далее в классах-наследниках будет приниматься решение о том, какой именно тип объекта будет создан

            string messageText = "Ваш номер заказа - 83456";

            // Отправляем заказ по SMS
            MessageSender sender = new SmsMessageSender("+79856455320");
            Message smsMessage = sender.Send(messageText);

            // Отправляем заказ по e-mail
            sender = new EmailMessageSender("orders@myshop.com");
            Message message = sender.Send(messageText);
        }
    }
}
